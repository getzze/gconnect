namespace Gconnect.Config {
    public const string BUILD_VERSION = "@GCONNECT_VERSION_MAJOR@.@GCONNECT_VERSION_MINOR@.@GCONNECT_VERSION_REVISION@";
    public const string PACKAGE_SUFFIX = "@GCONNECT_VERSION_API@";
    public const string APP_NAME = "@PROJECT_NAME@";

    public string parse_dbus_path (string path) {
        // TODO: replace characters that are not allowed as a dbus or GSettings path
        return path;
    }

    Config __instance = null;

    public class Config : Object {
        private GLib.Settings settings;
        private GLib.Settings root_devices_settings;
        private Gee.HashMap<string, GLib.Settings> devices_settings;
        private string _device_category = "desktop";
     
        internal Mconn.Crypt crypt_openssl { get; private set; default = null; }
        internal Crypt.Crypt crypt_gnutls { get; private set; default = null; }
        public TlsCertificate certificate { get; private set; default = null; }
        
        public string device_name {get; set;}

        public string device_id {get; private set;}
        
        public string device_category {
            get { return _device_category;}
        }

        private Config() {
            init_user_dirs();

            this.settings = new Settings("org.gconnect");
            this.settings.bind("name", this, "device_name", SettingsBindFlags.DEFAULT);
            this.settings.bind("id", this, "device_id", SettingsBindFlags.SET);
            if (!Guuid.is_valid(this.settings.get_string("id"))) {
                device_id = Guuid.random();
                info("Generate new uuid for the local server: %s", device_id);
            } else {
                device_id = this.settings.get_string("id");
            }
            this.root_devices_settings = new Settings("org.gconnect.paired-devices");
            this.devices_settings = new Gee.HashMap<string, GLib.Settings>();

 			init_crypto();

            load_paired_devices();
        }

        public static Config instance() {
            if (__instance == null) {
                var conf = new Config();
                __instance = conf;
            }
            return __instance;
        }

        public string[] get_paired_devices() {
            return this.settings.get_strv("paired-devices");
        }       

        public bool is_paired(string id) {
            var paired = new Gee.ArrayList<string>.wrap(this.get_paired_devices());
            return paired.contains(id);
        } 
              
        public bool has_certificate(string id) {
            if (is_paired(id)) {
                var dev = devices_settings[id];
                string? cert = dev.get_string("encryption-info");
                if (cert != null) {
                    return true;
                }
            }
            return false;
        }       

        public bool set_certificate_for_device(string id, string cert) {
            if (is_paired(id)) {
                var dev = devices_settings[id];
                dev.set_string("encryption-info", cert);
                dev.apply();
                return true;
            }
            return false;
        }       

        public string[] get_auto_pair_devices() {
            return this.settings.get_strv("auto-pair-devices");
        }       

        public void add_paired_device (string raw_id, DeviceManager.DeviceInfo dev_info) throws IOError {
            // Use a gsettings-compatible id.
            string id = parse_dbus_path(raw_id);

            var paired = new Gee.ArrayList<string>.wrap(this.get_paired_devices());
            
            if (!paired.contains(id)) {
                paired.add(id);
            }

            string new_path = this.settings.path + "devices/";
            var dev = new Settings.with_path("org.gconnect.device", new_path + id + "/");
            dev.set_string("id", raw_id);
            dev.set_string("name", dev_info.name);
            dev.set_string("type", dev_info.category);
            dev.set_int("protocol-version", dev_info.protocol_version);
            dev.set_strv("incoming-capabilities", dev_info.incoming);
            dev.set_strv("outgoing-capabilities", dev_info.outgoing);
            // Lan
            if (dev_info.encryption != "") {
                dev.set_string("encryption-info", dev_info.encryption);
            }
            if (dev_info.ip_address != "") {
                dev.set_string("ip-address", dev_info.ip_address);
            }

            devices_settings[id] = dev;
            dev.apply();
            
            this.settings.set_strv("paired-devices", paired.to_array());
            this.settings.apply();
            message("New trusted device added:\n%s", dev_info.to_string());
        }
        
        public void remove_paired_device (string raw_id) throws IOError {
            // Use a gsettings-compatible id.
            string id = parse_dbus_path(raw_id);

            var paired = new Gee.ArrayList<string>.wrap(this.get_paired_devices());
            if (!paired.contains(id)) {
                return;
            }
            if (!paired.remove(id)) {
                throw new IOError.FAILED("Could not remove id %s from the paired devices list: %s",
                        id, string.joinv(";", paired.to_array()));
            }
            var dev = devices_settings[id];
            dev.reset("id");
            dev.reset("name");
            dev.reset("type");
            dev.reset("protocol-version");
            dev.reset("incoming-capabilities");
            dev.reset("outgoing-capabilities");
            // Lan
            dev.reset("ip-address");
            dev.reset("encryption-info");
            dev.apply();
            devices_settings.unset(id);
            
            this.settings.set_strv("paired-devices", paired.to_array());
            this.settings.apply();
        }
        
        public DeviceManager.DeviceInfo get_paired_device(string raw_id) throws IOError {
            // Use a gsettings-compatible id.
            string id = parse_dbus_path(raw_id);

            DeviceManager.DeviceInfo dev_info = {};
            if (is_paired(id)) {
                var dev = devices_settings[id];
                dev_info.name = dev.get_string("name");
                dev_info.category = dev.get_string("type");
                dev_info.protocol_version = dev.get_int("protocol-version");
                dev_info.incoming = dev.get_strv("incoming-capabilities");
                dev_info.outgoing = dev.get_strv("outgoing-capabilities");
                // Lan
                dev_info.ip_address = dev.get_string("ip-address");
                dev_info.encryption = dev.get_string("encryption-info");
            } else {
                throw new IOError.FAILED("Could not retrieve device id %s from the paired devices list: %s",
                        id, string.joinv(";", devices_settings.keys.to_array()));
            }
            
            return dev_info;
        }
        
        private void load_paired_devices() {
            var paired = new Gee.ArrayList<string>.wrap(this.get_paired_devices());
            string new_path = this.settings.path + "devices/";
            foreach (var id in paired) {
                var dev = new Settings.with_path("org.gconnect.device", new_path + id + "/");
                devices_settings[id] = dev;
            }
        }
        
        public static string get_storage_dir() {
            return Path.build_filename(Environment.get_user_data_dir(),
                                    APP_NAME);
        }

        public static string get_config_dir() {
            return Path.build_filename(Environment.get_user_config_dir(),
                                    APP_NAME);
        }

        public static string get_cache_dir() {
            return Path.build_filename(Environment.get_user_cache_dir(),
                                    APP_NAME);
        }

        public static string get_plugins_local_dir() {
            return Path.build_filename(get_storage_dir(), "/plugins");
        }

        public static string get_plugins_global_dir() {
            return Path.build_filename("@CMAKE_INSTALL_FULL_DATADIR@", "@PROJECT_NAME@/plugins");
        }

        private static void init_user_dirs() {
            DirUtils.create_with_parents(get_storage_dir(), 0700);
            DirUtils.create_with_parents(get_config_dir(), 0700);
        }

        private static string get_private_key_path() {
            return Path.build_filename(get_storage_dir(), "/private.pem");
        }
        
        private static string get_certificate_path() {
            return Path.build_filename(get_storage_dir(), "/certificate.pem");
        }
        
        public string get_public_key_pem() {
//            var str = "-----BEGIN PUBLIC KEY-----\n\n-----END PUBLIC KEY-----\n";
            var str = "";
            if (crypt_openssl != null) {
                str = crypt_openssl.get_public_key_pem();
            }
            return str;
        }
        
        public ByteArray decrypt(Bytes chars) {
            ByteArray ret = null;
            if (crypt_openssl != null) {
                ret = crypt_openssl.decrypt(chars);
            }
            return ret;
        }
        
        private void init_crypto() {
            string key_path = get_private_key_path();
            string cert_path = get_certificate_path();
            // Check uuid size
            if (device_id.length != 36) {
                error("The UUID has not the correct size (63), certificate cannot be generated: %d", device_id.length);
            }
            GLib.Environment.set_variable("G_TLS_GNUTLS_PRIORITY", "NONE:+VERS-TLS1.0:+MAC-ALL:+ECDHE-ECDSA:+ECDHE-RSA:+AES-256-GCM:+AES-128-GCM:+AES-128-CBC:+ARCFOUR-128:+RSA:+SHA1:+SIGN-ALL:+COMP-NULL:+CURVE-ALL:+CTYPE-ALL", true); 
            crypt_gnutls = new Crypt.Crypt(key_path, cert_path, device_id);
//            crypt_openssl = new Mconn.Crypt.for_paths(key_path, cert_path);
            // TODO: use GnuTls generated certificate:
            // certtool --generate-privkey --bits 2048 --outfile private.pem
            // certtool --generate-self-signed --load-privkey private.pem --template template.cfg --outfile certificate.pem --hash SHA256 -q
            certificate = new TlsCertificate.from_files(get_certificate_path(), get_private_key_path());
            GLib.info("Certificate loaded from pem file.");
        }
    }
}
