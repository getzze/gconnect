using GnuTLS;

namespace Gconnect.Config {
    public const string BUILD_VERSION = "@GCONNECT_VERSION_MAJOR@.@GCONNECT_VERSION_MINOR@.@GCONNECT_VERSION_REVISION@";
    public const string PACKAGE_SUFFIX = "@GCONNECT_VERSION_API@";
    public const string APP_NAME = "@PROJECT_NAME@";
    public const string PLUGINS_DIR = "@CMAKE_INSTALL_FULL_DATADIR@/@GCONNECT_PLUGIN_SUBDIR@";

    public string parse_dbus_path (string path) {
        // TODO: replace characters that are not allowed as a dbus or GSettings path
        return path;
    }

    Config __instance = null;

    public class Config : Object {
        private GLib.Settings settings;
        private GLib.Settings root_devices_settings;
        private Gee.HashMap<string, GLib.Settings> devices_settings;
        private string _device_category = "desktop";
     
//        internal Mconn.Crypt crypt_openssl { get; private set; default = null; }
        public TlsCertificate certificate { get; private set; default = null; }
        
        public string device_name {get; set;}

        public string device_id {get; private set;}
        
        public string device_category {
            get { return _device_category;}
        }

        private Config() {
            init_user_dirs();

            this.settings = new Settings("org.gconnect");
            this.settings.bind("name", this, "device_name", SettingsBindFlags.DEFAULT);
            this.settings.bind("id", this, "device_id", SettingsBindFlags.SET);
            if (!Guuid.is_valid(this.settings.get_string("id"))) {
                device_id = Guuid.random();
                info("Generate new uuid for the local server: %s", device_id);
            } else {
                device_id = this.settings.get_string("id");
            }
            this.root_devices_settings = new Settings("org.gconnect.paired-devices");
            this.devices_settings = new Gee.HashMap<string, GLib.Settings>();

 			init_crypto();

            load_paired_devices();
        }

        public static Config instance() {
            if (__instance == null) {
                var conf = new Config();
                __instance = conf;
            }
            return __instance;
        }

        public string[] get_paired_devices() {
            return this.settings.get_strv("paired-devices");
        }       

        public bool is_paired(string id) {
            var paired = new Gee.ArrayList<string>.wrap(this.get_paired_devices());
            return paired.contains(id);
        } 
              
        public bool has_certificate(string id) {
            if (is_paired(id)) {
                var dev = devices_settings[id];
                string? cert = dev.get_string("encryption-info");
                if (cert != null) {
                    return true;
                }
            }
            return false;
        }       

        public bool set_certificate_for_device(string id, string cert) {
            if (is_paired(id)) {
                var dev = devices_settings[id];
                dev.set_string("encryption-info", cert);
                dev.apply();
                return true;
            }
            return false;
        }       

        public string[] get_auto_pair_devices() {
            return this.settings.get_strv("auto-pair-devices");
        }       

        public void add_paired_device (string raw_id, DeviceManager.DeviceInfo dev_info) throws IOError {
            // Use a gsettings-compatible id.
            string id = parse_dbus_path(raw_id);

            var paired = new Gee.ArrayList<string>.wrap(this.get_paired_devices());
            
            if (!paired.contains(id)) {
                paired.add(id);
            }

            string new_path = this.settings.path + "devices/";
            var dev = new Settings.with_path("org.gconnect.device", new_path + id + "/");
            dev.set_string("id", raw_id);
            dev.set_string("name", dev_info.name);
            dev.set_string("type", dev_info.category);
            dev.set_int("protocol-version", dev_info.protocol_version);
            dev.set_strv("incoming-capabilities", dev_info.incoming);
            dev.set_strv("outgoing-capabilities", dev_info.outgoing);
            // Lan
            if (dev_info.encryption != "") {
                dev.set_string("encryption-info", dev_info.encryption);
            }
            if (dev_info.ip_address != "") {
                dev.set_string("ip-address", dev_info.ip_address);
            }

            devices_settings[id] = dev;
            dev.apply();
            
            this.settings.set_strv("paired-devices", paired.to_array());
            this.settings.apply();
            message("New trusted device added:\n%s", dev_info.to_string());
        }
        
        public void remove_paired_device (string raw_id) throws IOError {
            // Use a gsettings-compatible id.
            string id = parse_dbus_path(raw_id);

            var paired = new Gee.ArrayList<string>.wrap(this.get_paired_devices());
            if (!paired.contains(id)) {
                return;
            }
            if (!paired.remove(id)) {
                throw new IOError.FAILED("Could not remove id %s from the paired devices list: %s",
                        id, string.joinv(";", paired.to_array()));
            }
            var dev = devices_settings[id];
            dev.reset("id");
            dev.reset("name");
            dev.reset("type");
            dev.reset("protocol-version");
            dev.reset("incoming-capabilities");
            dev.reset("outgoing-capabilities");
            // Lan
            dev.reset("ip-address");
            dev.reset("encryption-info");
            dev.apply();
            devices_settings.unset(id);
            
            this.settings.set_strv("paired-devices", paired.to_array());
            this.settings.apply();
        }
        
        public DeviceManager.DeviceInfo get_paired_device(string raw_id) throws IOError {
            // Use a gsettings-compatible id.
            string id = parse_dbus_path(raw_id);

            DeviceManager.DeviceInfo dev_info = {};
            if (is_paired(id)) {
                var dev = devices_settings[id];
                dev_info.name = dev.get_string("name");
                dev_info.category = dev.get_string("type");
                dev_info.protocol_version = dev.get_int("protocol-version");
                dev_info.incoming = dev.get_strv("incoming-capabilities");
                dev_info.outgoing = dev.get_strv("outgoing-capabilities");
                // Lan
                dev_info.ip_address = dev.get_string("ip-address");
                dev_info.encryption = dev.get_string("encryption-info");
            } else {
                throw new IOError.FAILED("Could not retrieve device id %s from the paired devices list: %s",
                        id, string.joinv(";", devices_settings.keys.to_array()));
            }
            
            return dev_info;
        }
        
        private void load_paired_devices() {
            var paired = new Gee.ArrayList<string>.wrap(this.get_paired_devices());
            string new_path = this.settings.path + "devices/";
            foreach (var id in paired) {
                var dev = new Settings.with_path("org.gconnect.device", new_path + id + "/");
                devices_settings[id] = dev;
            }
        }
        
        public static string get_storage_dir() {
            return Path.build_filename(Environment.get_user_data_dir(),
                                    APP_NAME);
        }

        public static string get_config_dir() {
            return Path.build_filename(Environment.get_user_config_dir(),
                                    APP_NAME);
        }

        public static string get_cache_dir() {
            return Path.build_filename(Environment.get_user_cache_dir(),
                                    APP_NAME);
        }

        public static string get_plugins_local_dir() {
            return Path.build_filename(get_storage_dir(), "/plugins");
        }

        public static string get_plugins_global_dir() {
            return Path.build_filename(PLUGINS_DIR);
        }

        private static void init_user_dirs() {
            DirUtils.create_with_parents(get_storage_dir(), 0700);
            DirUtils.create_with_parents(get_config_dir(), 0700);
        }

        private static string get_private_key_path() {
            return Path.build_filename(get_storage_dir(), "/private.pem");
        }
        
        private static string get_certificate_path() {
            return Path.build_filename(get_storage_dir(), "/certificate.pem");
        }
        
        public string get_public_key_pem() {
            var str = "";
//            if (crypt_openssl != null) {
//                str = crypt_openssl.get_public_key_pem();
//            }
            return str;
        }
        
        public ByteArray decrypt(Bytes chars) {
            ByteArray ret = null;
//            if (crypt_openssl != null) {
//                ret = crypt_openssl.decrypt(chars);
//            }
            return ret;
        }
        
        private void init_crypto() {
            string key_path = get_private_key_path();
            string crt_path = get_certificate_path();
            
            bool res = true;
            int res2 = 0;
            GLib.File file = null;
            
            file = File.new_for_path(key_path);
            if (!file.query_exists() || file.query_file_type(0) != FileType.REGULAR) {
                debug("Create a new private key");
                var new_key = GnuTLS.X509.PrivateKey.create();
                new_key.generate(GnuTLS.PKAlgorithm.RSA, 2048);
                res = Crypt.export_private_key_to_pem_file(new_key, key_path);
                if (!res) {
                    error("Could not generate the private key, aborting.");
                }
            }
            
            file = File.new_for_path(crt_path);
            if (!file.query_exists() || file.query_file_type(0) != FileType.REGULAR) {
                debug("Create a new self-signed certificate");
                GnuTLS.X509.PrivateKey priv_key = Crypt.import_private_key_from_pem_file(key_path);
                var new_crt = Crypt.certificate_create(priv_key, 2);  // Serial number 2

                var now = new DateTime.now_utc();
                res2 = new_crt.set_activation_time ((time_t)now.to_unix());
                res2 = new_crt.set_expiration_time ((time_t)now.add_years(10).to_unix());
                
                new_crt.set_dn_by_oid(GnuTLS.X509.OID_X520_COMMON_NAME, 0, device_id);
                new_crt.set_dn_by_oid(GnuTLS.X509.OID_X520_ORGANIZATION_NAME, 0, "KDE");
                new_crt.set_dn_by_oid(GnuTLS.X509.OID_X520_ORGANIZATIONAL_UNIT_NAME, 0, "KDE Connect");
                

                res2 = new_crt.set_key_purpose_oid(GnuTLS.X509.KP_TLS_WWW_CLIENT, false);
                res2 = new_crt.set_key_purpose_oid(GnuTLS.X509.KP_TLS_WWW_SERVER, false);
                res2 = new_crt.set_basic_constraints(1, -1); // CA authority

                // Sign certificate
                res2 = new_crt.sign2(new_crt, priv_key, GnuTLS.DigestAlgorithm.SHA256, 0);
                
                res = Crypt.export_certificate_to_pem_file(new_crt, crt_path);
                if (!res) {
                    error("Could not generate the certificate, aborting.");
                }
            }

            // For testing, use certtool to generate a GnuTls certificate:
            // certtool --generate-privkey --bits 2048 --outfile private.pem
            // certtool --generate-self-signed --load-privkey private.pem --template template.cfg --outfile certificate.pem --hash SHA256 -q
//            GLib.Environment.set_variable("G_TLS_GNUTLS_PRIORITY", "NONE:+VERS-TLS1.0:+MAC-ALL:+ECDHE-ECDSA:+ECDHE-RSA:+AES-256-GCM:+AES-128-GCM:+AES-128-CBC:+ARCFOUR-128:+RSA:+SHA1:+SIGN-ALL:+COMP-NULL:+CURVE-ALL:+CTYPE-ALL", true); 
            certificate = new TlsCertificate.from_files(crt_path, key_path);
            GLib.info("Certificate loaded from pem file.");
        }
    }
}
